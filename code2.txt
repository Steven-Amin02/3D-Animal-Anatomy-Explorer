<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Animal Anatomy Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Light palette */
      --bg: #F9FAFB;
      --surface: #FFFFFF;
      --surface-2: #F3F4F6;
      --text: #374151;
      --muted: #6B7280;
      --primary: #3B4CCA; /* Deep Indigo */
      --accent: #00BFA6;  /* Teal */
      --accent-2: #009E8E;
      --danger: #FF6B6B;
      --border: rgba(17, 24, 39, 0.08);
      --shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      --radius: 16px;

      /* Dark palette */
      --bg-dark: #111827;
      --surface-dark: #1F2937;
      --surface-2-dark: #2A3340;
      --text-dark: #E5E7EB;
      --muted-dark: #A0AEC0;
      --border-dark: rgba(255, 255, 255, 0.12);

      /* Hotspot */
      --hotspot-shadow: 0 0 0 2px rgba(0,191,166,0.25), 0 10px 20px rgba(0,191,166,0.35);
      --hotspot-pulse: rgba(0,191,166,0.4);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      overflow: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode {
      background: var(--bg-dark);
      color: var(--text-dark);
    }

    .container {
      display: flex;
      height: 100vh;
      position: relative;
      padding: 16px;
      gap: 16px;
    }

    /* Sidebar */
    .sidebar {
      width: 360px;
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px 20px 14px 20px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow-y: auto;
      border: 1px solid var(--border);
    }
    body.dark-mode .sidebar {
      background: var(--surface-dark);
      border-color: var(--border-dark);
    }

    .logo {
      display: flex; align-items: center; gap: 12px;
      font-weight: 800; font-size: 20px; letter-spacing: .3px; color: var(--primary);
    }
    .logo::before { content: "🧬"; font-size: 24px; }

    .section { display: flex; flex-direction: column; gap: 10px; }
    .section-title {
      font-size: 12px; font-weight: 700; letter-spacing: 1.3px;
      text-transform: uppercase; color: var(--muted);
    }
    body.dark-mode .section-title { color: var(--muted-dark); }

    .card {
      background: var(--surface-2);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid var(--border);
    }
    body.dark-mode .card {
      background: var(--surface-2-dark);
      border-color: var(--border-dark);
    }

    /* Theme Toggle */
    .theme-toggle {
      position: absolute; top: 24px; right: 24px;
      width: 48px; height: 48px; border-radius: 50%;
      background: var(--surface);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      cursor: pointer; display: grid; place-items: center;
      font-size: 22px; transition: transform 0.25s ease, background 0.3s ease, border-color 0.3s ease;
      z-index: 100;
    }
    .theme-toggle:hover { transform: translateY(-2px) scale(1.04); }
    body.dark-mode .theme-toggle { background: var(--surface-dark); border-color: var(--border-dark); }

    /* State Toggle */
    .state-toggle { display: flex; gap: 8px; background: transparent; }
    .state-btn {
      flex: 1; padding: 10px 12px; border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      font-weight: 700; font-size: 14px; cursor: pointer;
      transition: transform .15s ease, box-shadow .25s ease, background .25s ease, color .25s ease;
    }
    body.dark-mode .state-btn { background: var(--surface-dark); border-color: var(--border-dark); color: var(--text-dark); }
    .state-btn:hover { transform: translateY(-2px); box-shadow: var(--shadow); }
    .state-btn.active {
      background: #eef2ff;
      color: var(--primary);
      border-color: rgba(59, 76, 202, 0.35);
      box-shadow: 0 8px 18px rgba(59,76,202,0.12);
    }
    body.dark-mode .state-btn.active {
      background: rgba(59, 76, 202, 0.18);
      color: #BFD0FF;
    }

    /* Upload */
    .upload-area {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      background: var(--surface);
      color: var(--muted);
      cursor: pointer;
      transition: background .25s ease, border-color .25s ease, transform .15s ease, box-shadow .25s ease;
    }
    .upload-area:hover { background: var(--surface-2); transform: translateY(-2px); box-shadow: var(--shadow); }
    .upload-area.uploaded { border-color: rgba(0,191,166,0.6); background: #E6FFFA; color: #0F766E; }
    body.dark-mode .upload-area { background: var(--surface-dark); border-color: var(--border-dark); color: var(--muted-dark); }
    body.dark-mode .upload-area:hover { background: var(--surface-2-dark); }
    .upload-icon { font-size: 24px; }
    .upload-text { font-size: 13px; margin-top: 8px; }
    input[type="file"] { display: none; }

    /* Canvas Area */
    .canvas-area {
      flex: 1; position: relative; background: var(--surface);
      border-radius: var(--radius); border: 1px solid var(--border);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    body.dark-mode .canvas-area { background: var(--surface-dark); border-color: var(--border-dark); }
    #canvas3d { width: 100%; height: 100%; cursor: grab; }
    #canvas3d:active { cursor: grabbing; }

    /* Controls Overlay */
    .controls-overlay {
      position: absolute; top: 20px; right: 84px;
      display: flex; gap: 8px; align-items: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px; padding: 8px;
      box-shadow: var(--shadow);
      transition: background .25s ease, border-color .25s ease;
    }
    body.dark-mode .controls-overlay { background: var(--surface-dark); border-color: var(--border-dark); }
    .control-btn {
      width: 38px; height: 38px; border-radius: 10px; border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text);
      font-size: 18px; cursor: pointer;
      transition: transform .15s ease, background .25s ease, color .25s ease, box-shadow .25s ease;
    }
    .control-btn:hover { transform: translateY(-2px) scale(1.04); background: #eef2ff; color: var(--primary); box-shadow: var(--shadow); }
    body.dark-mode .control-btn { background: var(--surface-2-dark); border-color: var(--border-dark); color: var(--text-dark); }
    body.dark-mode .control-btn:hover { background: rgba(59, 76, 202, 0.18); color: #BFD0FF; }

    .instructions {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 16px;
      background: var(--surface);
      color: var(--muted);
      border: 1px solid var(--border);
      border-radius: 24px; padding: 10px 16px;
      box-shadow: var(--shadow);
      font-size: 12px;
      transition: background .25s ease, border-color .25s ease, color .25s ease;
    }
    body.dark-mode .instructions { background: var(--surface-dark); border-color: var(--border-dark); color: var(--muted-dark); }

    /* Loading */
    .loading {
      position: absolute; inset: 0; display: grid; place-items: center;
      pointer-events: none; color: var(--text);
    }
    .loading-inner {
      display: flex; flex-direction: column; align-items: center; gap: 10px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px; padding: 12px 16px; box-shadow: var(--shadow);
    }
    body.dark-mode .loading-inner { background: var(--surface-dark); border-color: var(--border-dark); }
    .spinner {
      width: 40px; height: 40px; border: 3px solid rgba(59,76,202,0.25);
      border-top-color: var(--primary);
      border-radius: 50%; animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Hotspots */
    .hotspot-layer { position: absolute; inset: 0; pointer-events: none; }
    .hotspot {
      position: absolute; width: 16px; height: 16px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--accent) 0%, var(--accent-2) 70%);
      box-shadow: var(--hotspot-shadow);
      transform: translate(-50%, -50%); pointer-events: auto; cursor: pointer;
      transition: transform .15s ease, box-shadow .2s ease;
      z-index: 5;
    }
    .hotspot:hover { transform: translate(-50%, -50%) scale(1.12); }
    .hotspot::after {
      content: ''; position: absolute; inset: -6px; border-radius: 50%;
      border: 2px solid var(--hotspot-pulse); animation: pulse 1.8s ease-out infinite;
    }
    @keyframes pulse { 0% { transform: scale(0.9); opacity: 1;} 100% { transform: scale(1.35); opacity: 0;} }
    /* Tooltip preview */
    .hotspot::before {
      content: attr(data-label);
      position: absolute; bottom: 120%; left: 50%;
      transform: translateX(-50%);
      background: #111827; color: #fff;
      font-size: 12px; padding: 4px 8px; border-radius: 6px; opacity: 0;
      pointer-events: none; transition: opacity 0.18s ease; white-space: nowrap;
    }
    .hotspot:hover::before { opacity: 1; }

    /* Info drawer (bottom sheet with tabs) */
    .info-drawer {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: var(--surface);
      border-top-left-radius: 16px; border-top-right-radius: 16px;
      border: 1px solid var(--border); box-shadow: 0 -12px 24px rgba(0,0,0,0.12);
      transform: translateY(100%); transition: transform 0.35s cubic-bezier(.4,0,.2,1);
      max-height: 44vh; overflow: hidden; z-index: 20;
    }
    body.dark-mode .info-drawer { background: var(--surface-dark); border-color: var(--border-dark); }
    .info-drawer.open { transform: translateY(0%); }
    .drawer-header {
      position: relative; display: flex; align-items: center; gap: 12px;
      padding: 12px 16px; border-bottom: 1px solid var(--border);
    }
    body.dark-mode .drawer-header { border-color: var(--border-dark); }
    .drawer-header::before {
      content: ''; position: absolute; top: 6px; left: 50%; transform: translateX(-50%);
      width: 42px; height: 4px; background: #d1d5db; border-radius: 2px;
    }
    body.dark-mode .drawer-header::before { background: #374151; }
    .drawer-icon { font-size: 18px; }
    .drawer-title { font-weight: 800; }
    .drawer-category { margin-left: auto; font-size: 11px; letter-spacing: 1.2px; color: var(--muted); text-transform: uppercase; }
    body.dark-mode .drawer-category { color: var(--muted-dark); }

    .drawer-tabs {
      display: flex; gap: 8px; padding: 8px 16px; border-bottom: 1px solid var(--border);
    }
    body.dark-mode .drawer-tabs { border-color: var(--border-dark); }
    .tab-btn {
      padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border);
      background: var(--surface-2); color: var(--text); font-weight: 600; font-size: 13px; cursor: pointer;
      transition: background .25s ease, color .25s ease, transform .15s ease, box-shadow .25s ease;
    }
    .tab-btn:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
    .tab-btn.active { background: #eef2ff; color: var(--primary); border-color: rgba(59,76,202,0.35); }
    body.dark-mode .tab-btn { background: var(--surface-2-dark); border-color: var(--border-dark); color: var(--text-dark); }
    body.dark-mode .tab-btn.active { background: rgba(59,76,202,0.18); color: #BFD0FF; }

    .drawer-body { padding: 12px 16px; overflow-y: auto; max-height: calc(44vh - 100px); }
    .drawer-desc { font-size: 14px; line-height: 1.7; color: var(--text); }
    body.dark-mode .drawer-desc { color: var(--text-dark); }

    .detail-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
    .detail-item {
      display: flex; gap: 10px; align-items: flex-start; background: var(--surface-2);
      border-radius: 12px; padding: 10px; border: 1px solid var(--border);
    }
    body.dark-mode .detail-item { background: var(--surface-2-dark); border-color: var(--border-dark); }
    .detail-emoji { font-size: 18px; }
    .detail-label { font-weight: 700; font-size: 12px; color: var(--text); }
    body.dark-mode .detail-label { color: var(--text-dark); }
    .detail-value { font-size: 12px; color: var(--muted); }
    body.dark-mode .detail-value { color: var(--muted-dark); }

    .media-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .media-item {
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      height: 100px;
      display: grid; place-items: center;
      color: var(--muted);
    }
    body.dark-mode .media-item { background: var(--surface-2-dark); border-color: var(--border-dark); }

    .drawer-close {
      margin-left: 8px; border: 1px solid var(--border);
      background: var(--surface-2); color: var(--text);
      border-radius: 10px; width: 34px; height: 34px; font-size: 16px; cursor: pointer;
      transition: transform .15s ease, box-shadow .25s ease, background .25s ease;
    }
    .drawer-close:hover { transform: translateY(-1px); box-shadow: var(--shadow); background: #eef2ff; color: var(--primary); }
    body.dark-mode .drawer-close { background: var(--surface-2-dark); border-color: var(--border-dark); color: var(--text-dark); }

    /* Focus styles for accessibility */
    :focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 3px;
    }

    @media (max-width: 1024px) {
      .container { padding: 12px; gap: 12px; }
      .sidebar { width: 340px; }
    }
    @media (max-width: 768px) {
      .container { flex-direction: column; }
      .sidebar { width: 100%; max-height: 42vh; }
      .controls-overlay { top: 12px; right: 12px; }
      .instructions { display: none; }
      .detail-grid { grid-template-columns: 1fr; }
      .media-grid { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar -->
    <aside class="sidebar" aria-label="Sidebar">
      <div class="logo">Anatomy Explorer</div>

      <section class="section">
        <div class="section-title">Visualization mode</div>
        <div class="state-toggle">
          <button class="state-btn active" data-state="normal" role="tab" aria-selected="true">🐾 Normal</button>
          <button class="state-btn" data-state="muscle" role="tab" aria-selected="false">💪 Muscles</button>
        </div>
      </section>

      <section class="section">
        <div class="section-title">Load 3D models</div>
        <div class="card">
          <label for="normalModel" class="upload-area" id="normalUpload" tabindex="0" aria-label="Upload normal model (.glb)">
            <div class="upload-icon">📦</div>
            <div class="upload-text">Upload Normal Model (.glb)</div>
          </label>
          <input type="file" id="normalModel" accept=".glb"/>
        </div>
        <div class="card">
          <label for="muscleModel" class="upload-area" id="muscleUpload" tabindex="0" aria-label="Upload muscle model (.glb)">
            <div class="upload-icon">📦</div>
            <div class="upload-text">Upload Muscle Model (.glb)</div>
          </label>
          <input type="file" id="muscleModel" accept=".glb"/>
        </div>
      </section>
    </aside>

    <!-- 3D Canvas Area -->
    <main class="canvas-area" aria-label="3D canvas area">
      <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">🌙</button>

      <canvas id="canvas3d" aria-label="3D view"></canvas>

      <div class="loading" id="loading" style="display: none;">
        <div class="loading-inner">
          <div class="spinner"></div>
          <div id="loadingText">Loading 3D Model...</div>
        </div>
      </div>

      <div class="controls-overlay" aria-label="View controls">
        <button class="control-btn" id="resetView" title="Reset view" aria-label="Reset view">🔄</button>
        <button class="control-btn" id="zoomIn" title="Zoom in" aria-label="Zoom in">➕</button>
        <button class="control-btn" id="zoomOut" title="Zoom out" aria-label="Zoom out">➖</button>
      </div>

      <div class="instructions">
        <span>🖱️ Drag to Rotate</span>
        <span>🔍 Scroll to Zoom</span>
        <span>📍 Click Hotspots</span>
      </div>

      <!-- Hotspots UI layer -->
      <div class="hotspot-layer" id="hotspotLayer"></div>

      <!-- Info Drawer -->
      <section class="info-drawer" id="infoDrawer" aria-live="polite">
        <div class="drawer-header">
          <span class="drawer-icon" id="drawerIcon">🔍</span>
          <span class="drawer-title" id="drawerTitle">Part</span>
          <span class="drawer-category" id="drawerCategory">Anatomy</span>
          <button class="drawer-close" id="drawerClose" title="Close details">✕</button>
        </div>
        <div class="drawer-tabs">
          <button class="tab-btn active" data-tab="overview">Overview</button>
          <button class="tab-btn" data-tab="details">Details</button>
          <button class="tab-btn" data-tab="media">Media</button>
        </div>
        <div class="drawer-body">
          <div id="tab-overview">
            <p class="drawer-desc" id="drawerDesc">Select a hotspot to view information.</p>
          </div>
          <div id="tab-details" style="display:none;">
            <div class="detail-grid" id="drawerDetails"></div>
          </div>
          <div id="tab-media" style="display:none;">
            <div class="media-grid" id="drawerMedia">
              <div class="media-item">No media yet</div>
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- Three.js and addons -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Anatomy data
    const anatomyData = {
      normal: {
        head: {
          title: "Head & Skull",
          category: "Skeletal Structure",
          icon: "🦴",
          description: "The head houses the brain and primary sensory organs. The skull protects the brain and provides structure for the face.",
          details: [
            { emoji: "🧠", label: "Function", value: "Protects the brain and sensory organs (eyes, ears, nose)" },
            { emoji: "🔬", label: "Composition", value: "Cranial and facial bones" },
            { emoji: "⚡", label: "Features", value: "Eye sockets, nasal cavity, jaw attachments" }
          ]
        },
        torso: {
          title: "Torso & Ribcage",
          category: "Core Structure",
          icon: "🫁",
          description: "The torso contains vital organs and provides the central framework for the body's structure.",
          details: [
            { emoji: "❤️", label: "Protection", value: "Ribcage shields heart, lungs, and major vessels" },
            { emoji: "🫁", label: "Respiration", value: "Diaphragm and ribs enable breathing" },
            { emoji: "🔗", label: "Connection", value: "Links upper and lower body via spine & pelvis" }
          ]
        },
        legs: {
          title: "Legs & Limbs",
          category: "Locomotion System",
          icon: "🦵",
          description: "Legs provide mobility, stability, and support the body's weight.",
          details: [
            { emoji: "🦴", label: "Bones", value: "Femur, tibia, fibula, foot bones" },
            { emoji: "🔄", label: "Joints", value: "Hip, knee, ankle enable complex movement" },
            { emoji: "⚖️", label: "Function", value: "Balance, running, jumping" }
          ]
        },
        tail: {
          title: "Tail",
          category: "Balance & Communication",
          icon: "🐾",
          description: "Tail helps with balance, communication, and thermoregulation.",
          details: [
            { emoji: "⚖️", label: "Balance", value: "Acts as a counterweight during movement" },
            { emoji: "💬", label: "Communication", value: "Expresses emotion and intent" },
            { emoji: "🦴", label: "Structure", value: "Caudal vertebrae with flexible joints" }
          ]
        },
        spine: {
          title: "Spine & Vertebrae",
          category: "Central Support",
          icon: "🦴",
          description: "The spine supports posture and protects the spinal cord while enabling flexibility.",
          details: [
            { emoji: "🛡️", label: "Protection", value: "Shields spinal cord and nerve roots" },
            { emoji: "💪", label: "Support", value: "Maintains posture and bears weight" },
            { emoji: "🔄", label: "Flexibility", value: "Allows bending and twisting" }
          ]
        },
        unknown: {
          title: "Part",
          category: "Anatomy",
          icon: "🔍",
          description: "This part doesn't have detailed info yet.",
          details: [
            { emoji: "📌", label: "Tip", value: "Map mesh names to data keys for richer info." }
          ]
        }
      },
      muscle: {
        head: {
          title: "Facial & Jaw Muscles",
          category: "Muscular System",
          icon: "💪",
          description: "Muscles controlling jaw motion and facial expressions.",
          details: [
            { emoji: "🍖", label: "Mastication", value: "Masseter & temporalis close the jaw" },
            { emoji: "😊", label: "Expression", value: "Facial muscles convey emotion" },
            { emoji: "⚡", label: "Strength", value: "High force relative to size" }
          ]
        },
        torso: {
          title: "Core & Respiratory Muscles",
          category: "Muscular System",
          icon: "🫁",
          description: "Essential for breathing, posture, and core stability.",
          details: [
            { emoji: "🫁", label: "Breathing", value: "Diaphragm & intercostals drive respiration" },
            { emoji: "💪", label: "Core", value: "Abdominals stabilize trunk and organs" },
            { emoji: "🔄", label: "Movement", value: "Rotation, bending, stabilization" }
          ]
        },
        legs: {
          title: "Leg Musculature",
          category: "Muscular System",
          icon: "🦵",
          description: "Powerful muscles enabling locomotion and balance.",
          details: [
            { emoji: "⚡", label: "Power", value: "Quadriceps extend, hamstrings flex knee" },
            { emoji: "🏃", label: "Movement", value: "Running, jumping, walking" },
            { emoji: "💪", label: "Push-off", value: "Calf muscles provide propulsion" }
          ]
        },
        tail: {
          title: "Tail Muscles",
          category: "Muscular System",
          icon: "🐾",
          description: "Fine control over tail position and movement.",
          details: [
            { emoji: "🔄", label: "Movement", value: "Small muscles enable precise positioning" },
            { emoji: "💬", label: "Expression", value: "Wagging, raising, curling" },
            { emoji: "⚖️", label: "Balance", value: "Dynamic adjustments while moving" }
          ]
        },
        back: {
          title: "Back Musculature",
          category: "Muscular System",
          icon: "💪",
          description: "Layers supporting posture and spinal protection.",
          details: [
            { emoji: "🦴", label: "Support", value: "Erector spinae maintain upright posture" },
            { emoji: "💪", label: "Power", value: "Latissimus dorsi drives pulling actions" },
            { emoji: "🛡️", label: "Stability", value: "Multiple layers protect the spine" }
          ]
        },
        unknown: {
          title: "Muscle",
          category: "Muscular System",
          icon: "🔍",
          description: "No detailed info available yet.",
          details: [
            { emoji: "📌", label: "Tip", value: "Map mesh names to data keys for richer info." }
          ]
        }
      }
    };

    // Optional explicit mesh name mapping (customize to your models)
    const partMap = {
      normal: { /* 'Skull': 'head', 'Ribcage': 'torso', 'Femur_L': 'legs', 'Tail_01': 'tail', 'Spine_01': 'spine' */ },
      muscle: { /* 'Masseter_L': 'head', 'Intercostals': 'torso', 'Quadriceps_L': 'legs', 'Tail_Muscle_01': 'tail', 'Latissimus': 'back' */ }
    };

    // Hotspots config: adapt meshName to your model names
    const hotspotConfig = {
      normal: [
        { meshName: 'Skull', key: 'head', offset: new THREE.Vector3(0, 0.06, 0) },
        { meshName: 'Ribcage', key: 'torso', offset: new THREE.Vector3(0.02, 0, 0) },
        { meshName: 'Femur_L', key: 'legs', offset: new THREE.Vector3(0, 0.04, 0) },
        { meshName: 'Tail_01', key: 'tail', offset: new THREE.Vector3(0, 0, 0.02) },
        { meshName: 'Spine_01', key: 'spine', offset: new THREE.Vector3(0, 0.02, 0) },
      ],
      muscle: [
        { meshName: 'Masseter_L', key: 'head', offset: new THREE.Vector3(0, 0.02, 0) },
        { meshName: 'Intercostals', key: 'torso', offset: new THREE.Vector3(-0.02, 0, 0) },
        { meshName: 'Quadriceps_L', key: 'legs', offset: new THREE.Vector3(0, 0.03, 0) },
        { meshName: 'Tail_Muscle_01', key: 'tail', offset: new THREE.Vector3(0, 0, -0.02) },
        { meshName: 'Latissimus', key: 'back', offset: new THREE.Vector3(-0.02, 0.02, 0) },
      ]
    };

    // Three.js core
    let scene, camera, renderer, controls, currentModel;
    let normalModel = null, muscleModel = null;
    let raycaster, mouse;
    let selectedMesh = null;
    let clock = new THREE.Clock();
    let autoMoveEnabled = true;

    // Hotspots state
    let hotspots = []; // { mesh, key, element, worldPos }

    init();

    function init() {
      const canvas = document.getElementById('canvas3d');

      // Scene
      scene = new THREE.Scene();
      scene.background = null;

      // Camera
      camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.set(0, 1, 3);

      // Renderer (performance-oriented)
      renderer = new THREE.WebGLRenderer({
        canvas,
        alpha: true,
        antialias: true,
        powerPreference: 'high-performance',
        preserveDrawingBuffer: false
      });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.shadowMap.enabled = false; // off to reduce lag

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.6);
      keyLight.position.set(4, 6, 8);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
      fillLight.position.set(-5, 2, -4);
      scene.add(fillLight);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.rotateSpeed = 0.85;
      controls.zoomSpeed = 0.9;
      controls.minDistance = 1;
      controls.maxDistance = 10;
      controls.target.set(0, 0.5, 0);
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.25;

      // Raycaster
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Theme persistence
      const body = document.body;
      const themeToggle = document.getElementById('themeToggle');
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        body.classList.add('dark-mode');
        themeToggle.textContent = '☀️';
        themeToggle.title = 'Switch to light mode';
      }
      themeToggle.addEventListener('click', () => {
        const dark = body.classList.toggle('dark-mode');
        themeToggle.textContent = dark ? '☀️' : '🌙';
        themeToggle.title = dark ? 'Switch to light mode' : 'Toggle dark mode';
        localStorage.setItem('theme', dark ? 'dark' : 'light');
      });

      // Saved state
      const savedState = localStorage.getItem('state');
      if (savedState && (savedState === 'normal' || savedState === 'muscle')) {
        document.querySelectorAll('.state-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`.state-btn[data-state="${savedState}"]`)?.classList.add('active');
        currentState = savedState;
      } else {
        currentState = 'normal';
      }

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === 'r' || e.key === 'R') resetView();
        if (e.key === '+' || e.key === '=') controls.dollyIn(1.25);
        if (e.key === '-' || e.key === '_') controls.dollyOut(1.25);
        if (e.key === ' ') { e.preventDefault(); autoMoveEnabled = !autoMoveEnabled; } // toggle bobbing
      });

      // Click on canvas for direct mesh selection (fallback)
      canvas.addEventListener('click', (e) => {
        if (!currentModel) return;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(currentModel, true);
        if (intersects.length > 0) {
          const object = intersects[0].object;
          const key = resolveInfoKey(object.name);
          showInfo(anatomyData[currentState][key] || anatomyData[currentState].unknown);
          highlightSelection(object);
        }
      });

      animate();

      // UI events
      document.querySelectorAll('.state-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.state-btn').forEach(b => {
            b.classList.remove('active');
            b.setAttribute('aria-selected', 'false');
          });
          btn.classList.add('active');
          btn.setAttribute('aria-selected', 'true');

          const next = btn.dataset.state;
          localStorage.setItem('state', next);
          if (next !== currentState) {
            currentState = next;
            const model = currentState === 'normal' ? normalModel : muscleModel;
            switchModel(model, currentState);
          } else {
            if (currentModel) buildHotspotsForState(currentState);
          }
        });
      });

      document.getElementById('normalModel').addEventListener('change', (e) => {
        if (e.target.files[0]) loadModel(e.target.files[0], 'normal');
      });
      document.getElementById('muscleModel').addEventListener('change', (e) => {
        if (e.target.files[0]) loadModel(e.target.files[0], 'muscle');
      });

      // Accessible label triggers
      document.getElementById('normalUpload').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') document.getElementById('normalModel').click();
      });
      document.getElementById('muscleUpload').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') document.getElementById('muscleModel').click();
      });

      document.getElementById('resetView').addEventListener('click', resetView);
      document.getElementById('zoomIn').addEventListener('click', () => controls.dollyIn(1.25));
      document.getElementById('zoomOut').addEventListener('click', () => controls.dollyOut(1.25));

      // Drawer tabs
      document.querySelectorAll('.tab-btn').forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
      });

      document.getElementById('drawerClose').addEventListener('click', () => {
        document.getElementById('infoDrawer').classList.remove('open');
      });

      // Resize with RAF debounce
      let resizeTimer = null;
      function onResize() {
        if (resizeTimer) cancelAnimationFrame(resizeTimer);
        resizeTimer = requestAnimationFrame(() => {
          const canvas = document.getElementById('canvas3d');
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(canvas.clientWidth, canvas.clientHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
          updateHotspotsScreenPositions();
        });
      }
      window.addEventListener('resize', onResize);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Subtle bobbing movement
      const t = clock.getElapsedTime();
      if (currentModel && autoMoveEnabled) {
        currentModel.position.y = Math.sin(t * 0.6) * 0.01;
      }

      controls.update();
      renderer.render(scene, camera);

      // Update hotspots positions
      updateHotspotsScreenPositions();
    }

    function resetView() {
      camera.position.set(0, 1, 3);
      controls.target.set(0, 0.5, 0);
      controls.update();
    }

    function resolveInfoKey(name = '') {
      const mapped = (partMap[currentState] && partMap[currentState][name]) || null;
      if (mapped) return mapped;
      const n = (name || '').toLowerCase();
      if (n.includes('leg') || n.includes('limb')) return 'legs';
      if (n.includes('torso') || n.includes('body') || n.includes('chest') || n.includes('rib')) return 'torso';
      if (n.includes('tail')) return 'tail';
      if (n.includes('spine') || n.includes('vertebra')) return currentState === 'muscle' ? 'back' : 'spine';
      if (n.includes('skull') || n.includes('head') || n.includes('face')) return 'head';
      return 'unknown';
    }

    function highlightSelection(mesh) {
      if (selectedMesh && selectedMesh.material && 'emissive' in selectedMesh.material) {
        selectedMesh.material.emissive.set(0x000000);
      }
      selectedMesh = mesh;
      if (mesh.material) {
        const mat = mesh.material.clone();
        mesh.material = mat;
        if ('emissive' in mat) {
          mat.emissive = new THREE.Color(0x3B4CCA);
          mat.emissiveIntensity = 0.35;
        }
      }
    }

    // Drawer rendering and tabs
    function showInfo(info) {
      const drawer = document.getElementById('infoDrawer');
      const iconEl = document.getElementById('drawerIcon');
      const titleEl = document.getElementById('drawerTitle');
      const catEl = document.getElementById('drawerCategory');
      const descEl = document.getElementById('drawerDesc');
      const detailsEl = document.getElementById('drawerDetails');

      iconEl.textContent = info.icon || '🔍';
      titleEl.textContent = info.title || 'Part';
      catEl.textContent = info.category || 'Anatomy';
      descEl.textContent = info.description || '';
      detailsEl.innerHTML = '';
      if (info.details?.length) {
        info.details.forEach(d => {
          const item = document.createElement('div');
          item.className = 'detail-item';
          item.innerHTML = `
            <div class="detail-emoji">${d.emoji}</div>
            <div>
              <div class="detail-label">${d.label}</div>
              <div class="detail-value">${d.value}</div>
            </div>
          `;
          detailsEl.appendChild(item);
        });
      } else {
        detailsEl.innerHTML = '<div class="detail-item"><div>ℹ️</div><div><div class="detail-label">No details</div><div class="detail-value">No details available for this part.</div></div></div>';
      }

      // Default to overview tab
      switchTab('overview');
      drawer.classList.add('open');
    }

    function switchTab(tab) {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
      document.getElementById('tab-overview').style.display = tab === 'overview' ? '' : 'none';
      document.getElementById('tab-details').style.display = tab === 'details' ? '' : 'none';
      document.getElementById('tab-media').style.display = tab === 'media' ? '' : 'none';
    }

    // Model loading
    function loadModel(file, type) {
      const loading = document.getElementById('loading');
      const loadingText = document.getElementById('loadingText');
      loading.style.display = 'grid';
      loadingText.textContent = 'Loading 3D Model...';

      const reader = new FileReader();
      reader.onload = (e) => {
        const arrayBuffer = e.target.result;
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);

        const loader = new THREE.GLTFLoader();
        loader.load(url, (gltf) => {
          URL.revokeObjectURL(url);
          const model = gltf.scene;

          // Prepare materials
          model.traverse((child) => {
            if (child.isMesh) {
              child.material.side = THREE.DoubleSide;
              if (!child.material.color) child.material.color = new THREE.Color(0xcccccc);
              child.frustumCulled = true;
            }
          });

          // Scale to fit
          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 2 / (maxDim || 1);
          model.scale.setScalar(scale);

          // Recenter after scaling
          const scaledBox = new THREE.Box3().setFromObject(model);
          const center = scaledBox.getCenter(new THREE.Vector3());
          model.position.sub(center);

          if (type === 'normal') {
            normalModel = model;
            if (currentState === 'normal') switchModel(model, 'normal');
          } else {
            muscleModel = model;
            if (currentState === 'muscle') switchModel(model, 'muscle');
          }

          loading.style.display = 'none';

          const uploadArea = document.getElementById(type + 'Upload');
          uploadArea.classList.add('uploaded');
          uploadArea.querySelector('.upload-icon').textContent = '✓';
          uploadArea.querySelector('.upload-text').textContent = `${type === 'normal' ? 'Normal' : 'Muscle'} Model Loaded`;

        }, (xhr) => {
          if (xhr.total) {
            const pct = Math.round((xhr.loaded / xhr.total) * 100);
            loadingText.textContent = `Loading 3D Model... ${pct}%`;
          } else {
            loadingText.textContent = `Loading 3D Model...`;
          }
        }, (error) => {
          console.error('Error loading model:', error);
          loading.style.display = 'none';
          alert('Error loading 3D model. Please make sure it is a valid .glb file.');
        });
      };
      reader.readAsArrayBuffer(file);
    }

    function switchModel(newModel, state) {
      // Remove current
      if (currentModel) {
        scene.remove(currentModel);
        selectedMesh = null;
        clearHotspots();
      }
      if (newModel) {
        currentModel = newModel;
        scene.add(newModel);
        buildHotspotsForState(state || currentState);
      } else {
        currentModel = null;
      }
    }

    // Hotspots: find meshes by name, compute center positions, place overlay dots
    function buildHotspotsForState(state) {
      const layer = document.getElementById('hotspotLayer');
      layer.innerHTML = '';
      hotspots = [];

      const cfg = hotspotConfig[state] || [];
      cfg.forEach(entry => {
        const mesh = currentModel.getObjectByName(entry.meshName);
        if (!mesh) return;

        const box = new THREE.Box3().setFromObject(mesh);
        const center = box.getCenter(new THREE.Vector3());
        const worldPos = center.clone().add(entry.offset || new THREE.Vector3());

        const dot = document.createElement('div');
        dot.className = 'hotspot';
        dot.title = anatomyData[state][entry.key]?.title || 'Info';
        dot.setAttribute('data-label', anatomyData[state][entry.key]?.title || 'Info');
        dot.tabIndex = 0;
        dot.addEventListener('click', (e) => {
          e.stopPropagation();
          showInfo(anatomyData[state][entry.key] || anatomyData[state].unknown);
          highlightSelection(mesh);
        });
        dot.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            showInfo(anatomyData[state][entry.key] || anatomyData[state].unknown);
            highlightSelection(mesh);
          }
        });
        layer.appendChild(dot);

        hotspots.push({ mesh, key: entry.key, element: dot, worldPos });
      });

      updateHotspotsScreenPositions();
    }

    function clearHotspots() {
      const layer = document.getElementById('hotspotLayer');
      layer.innerHTML = '';
      hotspots = [];
    }

    function updateHotspotsScreenPositions() {
      if (!hotspots.length || !currentModel) return;
      const canvas = renderer.domElement;
      const rect = canvas.getBoundingClientRect();

      hotspots.forEach(h => {
        const pos = h.worldPos.clone();
        pos.project(camera);
        const offscreen = (pos.z < -1 || pos.z > 1 || Math.abs(pos.x) > 1.1 || Math.abs(pos.y) > 1.1);
        h.element.style.display = offscreen ? 'none' : 'block';
        const x = ((pos.x + 1) / 2) * rect.width;
        const y = ((-pos.y + 1) / 2) * rect.height;
        h.element.style.left = `${x}px`;
        h.element.style.top = `${y}px`;
      });
    }
  </script>
</body>
</html>
```